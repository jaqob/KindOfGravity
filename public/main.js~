"use strict";
/// <reference path="lib/pixi.js.d.ts"/>
(function ()
{

    // Global variables
    var BOUNCE_FACTOR = 0.6,
    //var BOUNCE_FACTOR = 1,
    LEVEL_WIDTH = 1024,
    LEVEL_HEIGHT = 512,
    INFO_HEIGHT = 50;

    var data,
    jsonData,
    keyMap = [],
    lastTimeCount,
    count = 0,
    player,
otherPlayer,
    lastTime,
    currentLevel,
    healthBar,
    text,
    loadText,
    winnerText,
    collectedText = [],
    outerStage,
    loadingStage,
    infoStage,
    stage,
    gameLoop = update,
    nrOfPlayers = 1,
    loadingBackground;

  var socket = io();
  socket.emit('started', 'test');

	
	var tempCollisionTimer;

    var time = [];

    var renderer = PIXI.autoDetectRenderer(
            LEVEL_WIDTH,
            LEVEL_HEIGHT + INFO_HEIGHT,
        {
            view : document.getElementById("game-canvas")
        }
        );

    loadTextures();

    init();

    function init()
    {
        data = null,
        jsonData = null,
        keyMap = [],
        lastTimeCount = null,
        count = 0,
        player = null,
        lastTime = null,
        currentLevel = null,
        healthBar = null,
        text,
        loadText = null,
        winnerText = null,
        collectedText = [],
        outerStage = new PIXI.Container(0x000000),
        loadingStage = new PIXI.Container(0x000000),
        infoStage = new PIXI.Container(0x000000),
        stage = new PIXI.Container(0x000000),
        gameLoop = update,
        nrOfPlayers = null,
        loadingBackground = new PIXI.Graphics();

        loadingBackground = new PIXI.Graphics();
        loadingBackground.beginFill(0x000000);
        loadingBackground.drawRect(0, 0, LEVEL_WIDTH, LEVEL_HEIGHT + INFO_HEIGHT);

        loadingStage.addChild(loadingBackground);
        outerStage.addChild(loadingStage);
        loadText = new PIXI.Text("Loading textures",
            {
                font : "15px Arial",
                fill : "red",
            }
            );
        loadText.position.y = 25;
        loadText.position.x = 8;
        loadingStage.addChild(loadText);
        renderer.render(outerStage);

        continueInit();
    }

    function loadTextures()
    {
        //Load textures
        console.log("Downloading Textures");
        PIXI.loader.add('spriteSheet', "textures/mapSpritesheet.json?v=0.1");
        PIXI.loader.add('bullet3x3', "textures/bullet3x3.png");
        //PIXI.loader.add('concrete',"textures/concrete.png");
        //PIXI.loader.add('grass',"textures/grass.png");
        //PIXI.loader.add('mud8x8',"textures/mud8x8.png");
        PIXI.loader.add('ship16x24blue', "textures/ship16x24blue.png");
        PIXI.loader.add('ship16x24bluefire', "textures/ship16x24bluefire.png");
        PIXI.loader.add('ship16x24red', "textures/ship16x24red.png");
        PIXI.loader.add('ship16x24redfire', "textures/ship16x24redfire.png");
        PIXI.loader.add('logo', "textures/logo.png");
        PIXI.loader.add('gold1', "textures/gold1.png");
        PIXI.loader.add('gold2', "textures/gold2.png");
        PIXI.loader.add('gold3', "textures/gold3.png");
        PIXI.loader.add('gold4', "textures/gold4.png");
        PIXI.loader.once('complete', init);
        PIXI.loader.load();

    }

    function continueInit()
    {
        console.log("Loading Textures");
        loadText.text += " - Done\n"
        var logoSprite = new PIXI.Sprite(PIXI.loader.resources['logo'].texture);
        logoSprite.position.x = (LEVEL_WIDTH / 2) - (logoSprite.width / 2);
        logoSprite.position.y = 100;
        loadingStage.addChild(logoSprite);
        renderer.render(outerStage);
    }

    function loadLevelData(levelNr)
    {
        loadText.text += "Downloading Level Data"

        $.ajax(
        {
            type : 'GET',
            url : 'levels/Level' + levelNr + '.json?v=0.1',
            data : data,
            async : true,
            dataType : 'json',
            success : function (data)
            {
                jsonData = data;
                loadText.text += " - Done\n"
                renderer.render(outerStage);
                initLevel();
            },
            error : function (data)
            {
                jsonData = data;
                loadText.text += " - Fail\n"
                renderer.render(outerStage);
                //continueInit3();
            }
        }
        );
    }

    function initLevel()
    {
        if (stage)
        {
            outerStage.removeChild(stage);
            stage.removeChild(currentLevel);
            stage.destroy();
        }

        stage = new PIXI.Container(0x000000);

        //Only works if data is loaded
        LEVEL_WIDTH = jsonData.spritesWidth * 8;
        LEVEL_HEIGHT = jsonData.spritesHeight * 8;
        document.getElementById("game-canvas").width = LEVEL_WIDTH;
        document.getElementById("game-canvas").height = LEVEL_HEIGHT + INFO_HEIGHT;
        renderer.resize(LEVEL_WIDTH, LEVEL_HEIGHT + INFO_HEIGHT);
        loadingBackground.clear();
        loadingBackground.beginFill(0x000000);
        loadingBackground.drawRect(0, 0, LEVEL_WIDTH, LEVEL_HEIGHT + INFO_HEIGHT);

        loadText.text += "Processing Level"
        renderer.render(outerStage);
        currentLevel = new Level(jsonData);
        outerStage.removeChild(loadingStage);
        outerStage.addChild(stage);
        stage.addChild(currentLevel);

        loadText.text += "- Done\n"
        renderer.render(outerStage);
        outerStage.addChild(loadingStage);
        loadingStage.alpha = 0.9;
        renderer.render(outerStage);
    }

    function addPlayers()
    {
        loadText.text += "Adding Players - Done\n"
        outerStage.removeChild(loadingStage);
        infoStage.position.y = LEVEL_HEIGHT;
        outerStage.addChild(infoStage);

        if (player)
        {
            stage.removeChild(player);
            infoStage.removeChild(healthBar);
        }


        healthBar = new HealthBar(8, infoStage);
        player = new Player(jsonData.player1StartX, jsonData.player1StartY, currentLevel.realWidth, currentLevel.realHeight, "blue", stage);

        otherPlayer = new Player(jsonData.player1StartX+10, jsonData.player1StartY, currentLevel.realWidth, currentLevel.realHeight, "red", stage);

        collectedText[0] = new PIXI.Text("" + player.collected + " / " + currentLevel.toCollect,
            {
                font : "15px Arial",
                fill : "yellow",
            }
            );
        collectedText[0].position.x = 8;
        collectedText[0].position.y = 25;
        infoStage.addChild(collectedText[0]);

        outerStage.removeChild(loadingStage);
        outerStage.addChild(loadingStage);
        loadingStage.alpha = 0.9;
        renderer.render(outerStage);


    }

    function startGame()
    {
        if (text)
        {
            infoStage.removeChild(text);
        }
        text = new PIXI.Text("FPS: 0",
            {
                font : "15px Arial",
                fill : "red",
            }
            );
        text.position.y = 25;
        text.position.x = 200;
        infoStage.addChild(text);

        lastTimeCount = performance.now();
        lastTime = performance.now() - 16;
        outerStage.removeChild(loadingStage);
        gameLoop();
    }

    function end()
    {}

    function update()
    {
        var dT = performance.now() - lastTime;
        lastTime = performance.now();

        var dTfactor = dT / (1000 / 60);

        //If FPS lower than 6
        if (dTfactor > 10)
        {
            dTfactor = 10;
        }

        count++;
        var since = performance.now() - lastTimeCount;
        if (since >= 1000)
        {
            lastTimeCount = performance.now();
            text.text = "FPS: " + count;
            count = 0;

			
			//console.log("Collsion Timer: "  + (tempCollisionTimer/60));
			tempCollisionTimer=0;
			
        }
		
		

        time[0] = (performance.now() - lastTime);

        //Player 1
        handleHealth(0);
        collectedText[0].text = "" + player.collected + " / " + currentLevel.toCollect;

        //UP
        if (keyMap[38])
        {
            player.accelerate();
        }
        else
        {
            player.stopAccelerate();
        }
        //SPACE
        if (keyMap[17])
        {
            if (player.bullets.coolDown < 1)
            {
                player.bullets.addBullet(stage);
            }
        }
        player.bullets.coolDown -= 1 * dTfactor;

        if (keyMap[39])
        {
            player.rotateLeft(dTfactor);
        }
        if (keyMap[37])
        {
            player.rotateRight(dTfactor);
        }

        etcUpdate(0, dTfactor);

        exportData();

        renderer.render(outerStage);
        //setTimeout(gameLoop, 5);
        requestAnimationFrame(gameLoop);
    }

function exportData()
{
	var obj = new Object();
	obj.playerX = player.position.x;
	obj.playerY  = player.position.y;
	obj.playerRotation = player.rotation;
	obj.playerAcceleration = player.acceleration;
obj.removedTiles=currentLevel.removed;
	var jsonString= JSON.stringify(obj);
  	socket.emit('gameUpdate', jsonString);

}

    function handleHealth(playerNr)
    {
        if (player.health < 1)
        {
            healthBar.setHealth(0);
            stage.alpha /= 2;

            winnerText = new PIXI.Text("The End",
                {
                    font : "20px Arial",
                    fill : "red",
                }
                );
            winnerText.position.y = 20;
            winnerText.position.x = 500;
            infoStage.addChild(winnerText);
            gameLoop = end;
        }
        else
        {
            healthBar.setHealth(player.health);
        }
    }

    function etcUpdate(playerNr, dTfactor)
    {
        player.update(dTfactor);
        player.bullets.update(stage, dTfactor);
        var before = performance.now();
        collisionHandling2(currentLevel, player, dTfactor);
		bulletCollision2(currentLevel, player.bullets);
		tempCollisionTimer+=(performance.now()-before);	
        //console.log("collisionHandling Time: " + (performance.now()-before));      
    }

	
	
	    function bulletCollision2(level, bullets)
    {

        for (var bulletIndex = 0; bulletIndex < bullets.bullet.length; bulletIndex++)
        {

            if (!bullets.bullet[bulletIndex])
            {
                continue;
            }

             for (var currentIndex = 0; currentIndex < level.spriteChart.length; currentIndex++)

            {
                if (level.spriteChart[currentIndex])
                {
                        if (level.spriteChart[currentIndex])
                        {
                            var bX = bullets.bullet[bulletIndex].position.x;
                            if (((bullets.bullet[bulletIndex].position.y + bullets.bullet[bulletIndex].height <= level.spriteChart[currentIndex].position.y) ||
                                    (bullets.bullet[bulletIndex].position.y >= level.spriteChart[currentIndex].position.y + level.spriteChart[currentIndex].height) ||
                                    (bX >= level.spriteChart[currentIndex].position.x + level.spriteChart[currentIndex].width) ||
                                    (bX + bullets.bullet[bulletIndex].width <= level.spriteChart[currentIndex].position.x)) === false)
                            {
                                bullets.removeBullet(bulletIndex, stage);
                                level.hitTile(currentIndex);
                                break;
                            }
                        }
                    }

                }
            }
        
    };



	
    function bulletCollisionPlayer(player, bullets)
    {
        var hit = false;
        for (var bulletIndex = 0; bulletIndex < bullets.bullet.length; bulletIndex++)
        {
            hit = false;
            if (!bullets.bullet[bulletIndex])
            {
                continue;
            }
            var bX = bullets.bullet[bulletIndex].position.x;
            if (((bullets.bullet[bulletIndex].position.y + bullets.bullet[bulletIndex].height <= player.getRealY()) ||
                    (bullets.bullet[bulletIndex].position.y >= player.getRealY() + player.height) ||
                    (bX >= player.getRealX() + player.width) ||
                    (bX + bullets.bullet[bulletIndex].width <= player.getRealX())) === false)
            {
                bullets.removeBullet(bulletIndex, stage);
                player.hit();

                break;
            }
        }
    };
	
	
	function collisionHandling2(level, player, dTfactor)
    {
        var playerRealX = player.getRealX();
        var playerRealY = player.getRealY();
        var currentIndex;
		
		//console.log(level.spriteChart.length + " vs " + (level.nrSpritesWidth*level.nrSpritesHeight));
		
        for (var currentIndex = 0; currentIndex < level.spriteChart.length; currentIndex++)
        {
                    if (level.spriteChart[currentIndex])
                    {
                        if (((playerRealY + player.shipHeight <= level.spriteChart[currentIndex].position.y) ||
                                (playerRealY >= level.spriteChart[currentIndex].position.y + level.spriteChart[currentIndex].height) ||
                                (playerRealX >= level.spriteChart[currentIndex].position.x + level.spriteChart[currentIndex].width) ||
                                (playerRealX + player.width <= level.spriteChart[currentIndex].position.x)) === false)
                        {
                            if (level.spriteChart[currentIndex].collectable === 1)
                            {
                                level.collect(currentIndex);
                                player.collected++;
                            }
                            else
                            {

                                var w = (player.width + level.spriteChart[currentIndex].width) / 2;
                                var h = (player.shipHeight + level.spriteChart[currentIndex].height) / 2;
                                var dx = player.position.x - (level.spriteChart[currentIndex].position.x + level.spriteChart[currentIndex].width / 2);
                                var dy = player.position.y - (level.spriteChart[currentIndex].position.y + level.spriteChart[currentIndex].height / 2);

                                player.velocity_y = player.velocity_y * -0.1;
                                player.velocity_x = player.velocity_x * -0.1;
                                while (((playerRealY + player.shipHeight <= level.spriteChart[currentIndex].position.y) ||
                                        (playerRealY >= level.spriteChart[currentIndex].position.y + level.spriteChart[currentIndex].height) ||
                                        (playerRealX >= level.spriteChart[currentIndex].position.x + level.spriteChart[currentIndex].width) ||
                                        (playerRealX + player.width <= level.spriteChart[currentIndex].position.x)) === false)
                                {
                                    player.updatePosition(dTfactor);
                                    playerRealX = player.getRealX();
                                    playerRealY = player.getRealY();
                                }
                                //Reduce the risk to get stuck by moving one more step
                                player.updatePosition(dTfactor);
                                player.velocity_y = player.velocity_y * -10;
                                player.velocity_x = player.velocity_x * -10;

                                var wy = w * dy;
                                var hx = h * dx;

                                if (wy > hx)
                                {
                                    if (wy > -hx)
                                    {
                                        //console.log("UP");
                                        player.velocity_y = player.velocity_y * -BOUNCE_FACTOR;
                                        player.velocity_x = player.velocity_x * BOUNCE_FACTOR;
                                        player.hit();

                                    }
                                    else
                                    {
                                        //console.log("LEFT");
                                        player.velocity_x = player.velocity_x * -BOUNCE_FACTOR;
                                        player.velocity_y = player.velocity_y * BOUNCE_FACTOR;
                                        player.hit();
                                    }
                                }
                                else
                                {
                                    if (wy > -hx)
                                    {
                                        //console.log("RIGHT");
                                        player.velocity_x = player.velocity_x * -BOUNCE_FACTOR;
                                        player.velocity_y = player.velocity_y * BOUNCE_FACTOR;
                                        player.hit();
                                    }
                                    else
                                    {
                                        //console.log("DOWN");
                                        player.velocity_y = player.velocity_y * -BOUNCE_FACTOR;
                                        player.velocity_x = player.velocity_x * BOUNCE_FACTOR;
                                        if (Math.abs(Math.sin(player.rotation)) > 0.4)
                                        {
                                            player.hit();
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    }

                }
    };
	

    document.onkeyup = document.onkeydown = function (e)
    {
        keyMap[e.keyCode] = e.type == 'keydown';
        //console.log("UP:" + map[38] + " DOWN:" + map[40] + " LEFT:" + map[39] + " RIGHT:" + map[37]);
    }

    $('#start').on('click', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("Start");
        startGame();
    }
    );

    $('#reset').on('click', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("reset");
        /*
        $("btn btn-primary").prop('checked', false);
        $("#level1").prop('checked', false);
        $("#level2").prop('checked', false);
        $("#p1").prop('checked', false);
        $("#p2").prop('checked', false);
         */

        $('.btn-group').find('label').removeClass('active')
        .end().find('[type="radio"]').prop('checked', false);
        $("#levelDiv").hide();
        gameLoop = end;
        init();

    }
    );

    $('#level1').on('change', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("level1");
        //continueInit4();
        $("#start").prop('disabled', false);
        $("levelDiv").show();
        $(".levelDiv").show();
        $("#levelDiv").show();
        loadLevelData(1);
    }
    );
    $('#level2').on('change', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("level2");
        //continueInit4();
        $("#start").prop('disabled', false);
        $("#levelDiv").show();
        loadLevelData(2);
    }
    );

    $('#level3').on('change', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("level2");
        //continueInit4();
        $("#start").prop('disabled', false);
        $("#levelDiv").show();
        loadLevelData(3);
    }
    );

    $('#1p').on('change', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("1p");
        nrOfPlayers = 1;
        addPlayers();
    }
    );
    $('#2p').on('change', function (event)
    {
        event.preventDefault(); // To prevent following the link (optional)
        console.log("2p");
        nrOfPlayers = 2;
        addPlayers();

    }
    );

socket.on('gameUpdateToAll', function(msg){
    //console.log("update " + msg );
if(otherPlayer)
{
var obj = JSON.parse(msg);
otherPlayer.position.x = obj.playerX;
otherPlayer.position.y = obj.playerY;
otherPlayer.rotation = obj.playerRotation;
if(obj.playerAcceleration > 0)
{
otherPlayer.texture = otherPlayer.shipTextureFire; 
}
else
{
otherPlayer.texture = otherPlayer.shipTexture;
}


for (var index = 0; index < obj.removedTiles; index++)
{
currentLevel.hitTile(obj.removedTiles[index]);
}

}
});

}
)();
